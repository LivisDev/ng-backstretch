{"version":3,"sources":["../src/ng-backstretch.js"],"names":["angular","module","directive","$window","$timeout","restrict","scope","images","duration","fade","link","element","attributes","Array","isArray","length","styles","wrapper","left","top","overflow","margin","padding","height","width","zIndex","position","image","opacity","border","maxHeight","maxWidth","transition","css","forEach","index","array","src","append","load","e","ratio","this","_resize","show","resize","background_offset","background_css","root_width","offsetWidth","background_width","root_height","offsetHeight","isObject","offsetParent","background_height","i","children","bind","$on","unbind"],"mappings":"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","file":"ng-backstretch.min.js","sourcesContent":["/*!\n * ng-backstretch\n * https://github.com/rprovost/ng-backstretch\n *\n * Copyright (c) 2014-2015 Ryan Provost\n * Licensed under the MIT license.\n */\nangular.module('ng-backstretch', []).\n\ndirective('backstretch', ['$window', '$timeout', function($window, $timeout) {\n  return {\n    restrict: 'A',\n    scope: {\n      images: '&backstretchImages',\n      duration: '&backstretchDuration',\n      fade: '&backstretchFade'\n    },\n    link: function(scope, element, attributes) {\n\n      /* In its simplest form, we allow Backstretch to be called on an image path.\n       * e.g. <div backstretch backstretch-url=\"'/path/to/image.jpg'\">\n       * So, we need to turn this back into an array.\n       */\n      scope.images = Array.isArray(scope.images()) ? scope.images() : [scope.images()];\n      scope.duration = scope.duration() || 5000;\n      scope.fade = scope.fade() || 0;\n\n      // We need at least one image or method name\n      if (scope.images.length === 0) {\n        return false;\n      }\n\n      /* STYLES\n       * \n       * Baked-in styles that we'll apply to our elements.\n       * In an effort to keep the plugin simple, these are not exposed as options.\n       * That said, anyone can override these in their own stylesheet.\n       * ========================= */\n      var styles = {\n        wrapper: {\n          left: 0,\n          top: 0,\n          overflow: 'hidden',\n          margin: 0,\n          padding: 0,\n          height: '100%',\n          width: '100%',\n          zIndex: -999998,\n          position: 'absolute'\n        },\n        image: {\n          position: 'absolute',\n          opacity: 0,\n          margin: 0,\n          padding: 0,\n          border: 'none',\n          width: 'auto',\n          height: 'auto',\n          maxHeight: 'none',\n          maxWidth: 'none',\n          zIndex: -999999,\n          transition: 'all '+scope.fade+'s'\n        }\n      };\n\n      // create the scope.wrapper element\n      scope.wrapper = angular.element('<div class=\"backstretch\"></div>');\n      scope.wrapper.css(styles.wrapper);\n\n      scope.images.forEach(function(element, index, array){\n        scope.image = angular.element('<img>');\n        scope.image[0].src = element;\n        scope.image.css(styles.image);\n\n        // append these images to the wrapper\n        scope.wrapper.append(scope.image);\n      });\n\n      // append the wrapper\n      element.append(scope.wrapper);\n\n      // Set the first image\n      scope.index = 0;\n\n      scope.load = function(e) {          \n        // figure out what the width:height ratio is\n        scope.ratio = this.width / this.height;\n\n        // perform an initial sizing\n        scope._resize();\n\n        // display the first image\n        scope.show(scope.index++);\n      };\n\n      scope.resize = function(e) {\n        if (scope.fade > 0) {\n          $timeout(scope._resize, 0.5*(scope.fade*1000));\n          $timeout(scope._resize, (scope.fade*1000));\n          $timeout(scope._resize, (scope.fade*1000)+500);\n        } else {\n          $timeout(scope._resize, 1000);\n        }\n      };\n\n      scope._resize = function(e) {\n\n        // set some default css\n        var background_css = {left: 0, top: 0, width: 'auto', height: 'auto'};\n\n        // set some initial calculations\n        var root_width = element[0].offsetWidth,\n            background_width = root_width,\n\n            // Check which height-element that should be used\n            root_height = element[0].offsetHeight > 0 ? element[0].offsetHeight : (angular.isObject(element[0].offsetParent) ? element[0].offsetParent.offsetHeight : 0),\n            background_height = background_width / scope.ratio,\n\n            background_offset;\n\n        // make adjustments based on image ratio\n        if (background_height >= root_height) {\n          background_offset = (background_height - root_height) / 2;\n          background_css.top = '-' + background_offset + 'px';\n\n        } else {\n          background_height = root_height;\n          background_width = background_height * scope.ratio;\n          background_offset = (background_width - root_width) / 2;\n\n          background_css.left = '-' + background_offset + 'px';\n        }\n\n        // set the css for the width and height\n        background_css.width = background_width + 'px';\n        background_css.height = background_height + 'px';\n\n        // apply the appropriate styles to the wrapper and image\n        scope.wrapper.css({ width: root_width, height: root_height });\n\n        for(var i = 0; i < scope.wrapper.children().length; i++) {\n          var img = angular.element(scope.wrapper.children()[i]);\n          img.css(background_css);\n        }\n      };\n\n      scope.show = function(index) {\n\n        var element = scope.wrapper.children()[index];\n        scope.image = angular.element(element);\n\n        // only one image\n        if (scope.images.length === 1) {\n          scope.image.css({opacity:1});\n          return;\n        }\n\n        // bring things back around once we've hit the end\n        if (index >= scope.images.length-1) {\n          scope.index = 0;\n        }\n\n        // show the image since it's finished loading\n        scope.image.css({opacity:1});\n\n        // hide it once the duration has been reached\n        $timeout(function(){\n          scope.image.css({opacity:0});\n        }, scope.duration);\n\n        $timeout(function(){\n          scope.show(scope.index++);\n        }, scope.duration);\n      };\n\n      // don't do anything until the image has finished loading\n      scope.image.bind('load', scope.load);\n\n      // make sure to update the image sizes when the page scales/changes\n      angular.element($window).bind('resize', scope.resize);\n      angular.element($window).bind('orientationchange', scope.resize);\n\n      // Unbinds resize listener on $destroy event. It prevents listener to be called, which caused error mentioned in #22\n      scope.$on('$destroy', function() {\n        angular.element($window).unbind('resize', scope.resize);\n        angular.element($window).unbind('orientationchange', scope.resize);\n      });\n    }\n  };\n}]);\n"]}